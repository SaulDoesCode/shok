<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/marx.css">
    <link rel="stylesheet" href="/ks.css">
    <title>kurshok.space</title>
</head>
<body>
    <header>
        <h1><span>kur</span><span>shok</span></h1>
        <nav class="vs">
            <header class="avd"></header>

        </nav>
        <input type="search">
    </header>
    <main>

    </main>

    <script type="module">
        import d from "/domlib.js"
        import http from "/http.js"

        const svsapi = '/api/svs/', svs = new Proxy({
            async get(m) { return await http.get(svsapi+m) },
            async set(m, v) { return await http.post(svsapi+m, v) },
            async delete(m) { return await http.del(svsapi+m) }
        }, {
            async get(m, k) { return k in m ? m[k] : (await m.get(k)).value },
            async set(m, k, v) { return await m.set(k, v) },
            async deleteProperty(m, k) { return await m.delete(k) }
        })

        const {query, queryEach, render, domfn} = d
        const {section, div, button, span, p, header, article, textarea, html} = domfn

        const main = query('main')
        const vs = query('.vs')
        const avd = query('.avd')
        const si = query('input[type=search]')

        const views = Object.create(null)
        const view = (title, v) => {
            if (v != null) {
                views[title] = v
                return vs.appendChild(span({
                    attr: {title},
                    onpointerdown(e) {(e.preventDefault(), view(title))}
                }))
            }
            main.innerHTML = ''
            localStorage.setItem('av', title)
            render(views[avd.textContent = title], main)
        }

        const blog = section.blog()
        let lastSearchQuery = ''
        const searchForWrits = async (q = search.value, p = 0, k = 'post') => {
            const [writs, monikers] = await http.get('/api/search?q=' + q + `&p=${p}&k=${k}`)
            if (writs.length) {
                p = lastSearchQuery !== q ? 0 : p + 1
                lastSearchQuery = q
                blog.innerHTML = ''
                let i = -1
                for (const writ of writs) {
                    blog.append(article.writ(html`
                        <header>
                            <h2>${writ.title}</h2>
                            <span>${writ.ts}</span>
                            <span>${monikers[++i]}</span>
                        </header>
                        <section>${writ.content}</section>
                        <footer>
                            <p>${writ.tags}</p>
                        </footer>
                    `))
                }
            } else {
                const nf = span.nothing_found({$:si.parentNode}, 404)
                setTimeout(() => nf.remove(), 3500)
            }
        }

        searchForWrits('post')
        si.onkeydown = e => {
            if (e.key === 'Enter') {
                searchForWrits(si.value)
                view('blog')
            }
        }

        view('blog', blog)

        view('writer', section.writ_writer('writ writer..'))

        view('about', section.about(
            `Homespun server and frontend`
        ))

        view(localStorage.getItem('av') || 'blog')

        const whos = JSON.parse(localStorage.getItem('whos') || '{}')
        const status = header.status('Connecting...')
        const chatMessages = article.messages()
        const chatInput = textarea()
        chatInput.placeholder = 'type a message..'
        // on control+enter, send message
        chatInput.onkeydown = async e => {
            if (!e.ctrlKey && e.key === 'Enter') {
                e.preventDefault()
                const body = chatInput.value.trim()
                await fetch(`/api/chat`, {method: "POST", body})
                showMessage('me', body)
                chatInput.value = ''
            }
        }
        const chatRoot = section.chat({$: 'body'}, status, chatMessages, chatInput)

        const makeMessage = async (who, data) => {
            if (who != 'me') {
                if (who != null && whos[who] == null) {
                    whos[who] = (await http.get('/api/moniker-lookup/' + who)).moniker
                    localStorage.setItem('whos', JSON.stringify(whos))
                }
            }
            const msg = article.message({$: chatMessages}, span.who[whos[who]](whos[who] || 'me'), p(data))
            if (who == 'me') msg.classList.add('me')
            const msgs = [...(JSON.parse(localStorage.getItem('c') || '[]')), [who, data]]
            for (let i = 0; i < msgs.length; i++) {
                for (let j = 0; j < msgs.length; j++) {
                    if (i == j) continue
                    if (msgs[i][0] == msgs[j][0] && msgs[i][1] == msgs[j][1]) {
                        msgs.splice(j, 1)
                    }
                }
            }
            localStorage.setItem('c', JSON.stringify([...msgs]))
        }
        const showMessage = async (who, data) => {
            if (data == null && who.includes(":")) {
                let wd = who.split(":")
                who = wd.shift()
                data = wd.join(':')
                if (who == 'me') return makeMessage(who, data)
            } else {
                whos[who] = who
            }
            makeMessage(who, data)
        }
        JSON.parse(localStorage.getItem('c') || '[]').forEach(wd => makeMessage(...wd))

        let sse = new EventSource(`/api/chat`), sid
        sse.addEventListener("account", e => sid = e.data)
        sse.addEventListener("message", e => showMessage(e.data))
        sse.addEventListener("open", () => status.innerHTML = "Connected!")
        sse.addEventListener("error", async e => {
            sse.close()
            status.innerHTML = "Disconnected!"
            status.classList.add('error')
            await showMessage(`error: ${e}`)
        })
    </script>
</body>
</html>