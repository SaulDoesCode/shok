<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/marx.css">
    <link rel="stylesheet" href="/ks.css">
    <title>kurshok.space</title>
</head>
<body>
    <header>
        <h1><span class="kur">kur</span><span class="shok">shok</span></h1>
        <nav class="vs">
            <header class="avd"></header>

        </nav>
        <input type="search">

        <section class="auth" title="register/login">
            <span class="inputs">
                <input type="text" placeholder="moniker">
                <input type="password" placeholder="password">
            </span>
            <button class="auth-btn" title="authenticate">üîì</button>
        </section>
    </header>
    <main>

    </main>

    <script type="module">
        import d from "/domlib.js"
        import http from "/http.js"

        const {query, queryEach, render, domfn} = d
        const {section, div, button, span, p, header, article, input, textarea, html} = domfn

        const displayObjectText = obj => {
            let text = ''
            for (const key in obj) text += `${key}: ${obj[key]}\n`
            return text
        }

        const authenticate = async () => {
            const ae = query('.auth')
            try {
                const moniker = query('[type="text"]', ae).value.trim()
                const data = await http.post('/auth', {
                    moniker,
                    pwd: query('[type="password"]', ae).value.trim()
                })
                if (data.err == null) {
                    ae.innerHTML = `<p>Authenticated</p><p>Info: ${displayObjectText(data)}</p>`
                    setTimeout(() => { ae.remove() }, 4200)
                    localStorage.setItem('auth', moniker)
                }
            } catch(e) {
                const errMsg = html`<p class="auth-err">Authentication Failed, error: ${e}</p>`[0][0]
                ae.append(errMsg)
                setTimeout(() => errMsg.remove(), 4200)
            }
        }

        const ae = query('.auth')
        if (localStorage.getItem('auth')) {
            ae.innerHTML = ''
            button.unauth({
                $: ae,
                attr: {
                    title: 'Unauthenticate/Logout'
                },
                async onpointerdown(e) {
                    localStorage.removeItem('auth')
                    const data = await http.get('/unauth')
                    query('.auth').innerHTML = `
                        <p>Unauthenticated</p>
                        <p>Server Response Info: ${displayObjectText(data)}</p>
                    `
                    setTimeout(() => location.reload(), 4200)
                }
            }, 'üîí ')
            ae.classList.add('unauth')
        } else {
            query('button', ae).onpointerdown = e => authenticate()
            query('[type="password"]', ae).onkeydown = e => {
                if (e.key === 'Enter') authenticate()
            }
        }

        const main = query('main')
        const vs = query('.vs')
        const avd = query('.avd')
        const si = query('input[type=search]')

        const views = Object.create(null)
        let activeView
        const view = async (title, v) => {
            if (v != null) {
                views[title] = v
                return vs.appendChild(span({
                    attr: {title},
                    onpointerdown(e) {(e.preventDefault(), view(title))}
                }))
            }
            if (title == activeView) return
            main.innerHTML = ''
            localStorage.setItem('av', title)
            v = views[activeView = avd.textContent = title]
            if (v.constructor.name == 'AsyncFunction') views[title] = v = await v()
            else if (typeof v == 'function') views[title] = v = v()
            render(v, main)
        }

        const divider = "<span class=\"divider\"> | </span>"
        const niceTime = ts => `${(ts = new Date(ts * 1000)).getFullYear() - 2000}/${ts.getMonth()}/${ts.getDate()} ${ts.getHours()}:${ts.getMinutes()}${ts.getSeconds() == 0 ? '' : ':' + ts.getSeconds()}`

        const writLikes = async ts => {
            try {
                const res = await (await fetch('/api/writ-likes/' + ts)).json()
                if (!res.err) {
                    return res[0] && res[0].length || 0
                }
            } catch(e) {}
            return 0
        }

        window.likeWrit = async (ts, el) => {
            const res = await (await fetch(`/api/like/${ts}`)).json()
            try {
                el.parentNode.querySelector('.likes').textContent = await writLikes(ts)
            } catch(e) {}
            return res.ok
        }

        const makeComment = c => {
           const likesView = span.likes('likes: ', c.likes.length)
           const delBtn = localStorage.getItem('auth') == c.owner_moniker ? button({async onpointerdown() {
               const status = await http.del('/api/search/' + c.ts)
               if (!status.err) cmt.remove()
           }}, 'delete') : ''
           const likeBtn = button({async onpointerdown() {
               c.liked = !c.liked
               if (c.liked) {
                    const res = await http.get(`/api/unlike/${c.ts}`)
                    likesView.innerHTML = 'likes: ' + res.likes.length
               } else {
                    const res = await http.get(`/api/like/${c.ts}`)
                    likesView.innerHTML = 'likes: ' + res.likes.length
               }
           }}, c.liked ? 'üëé' : 'üëç') 
           const cmt = article.comment(header(span.owner(c.owner_moniker), likesView), section.content(c.content), div.interface(
                delBtn,
                likeBtn
           ))
           return cmt
        }

        window.fetchComments = async (ts, el) => {
            let comments
            try {
                comments = await http.get(`/api/search?q=tags:"comment ${ts}"&k=comment`)
            } catch(e) {
                showMessage('error', 'comments failed to load: ' + e)
            }

            const $ = el.parentNode.parentNode.parentNode
            const commentsEl = $.querySelector('.comments')
            if (commentsEl) {
                commentsEl.remove()
            } else {
                if (comments && comments.length == 0) showMessage('error', 'no comments found')
                const commentWriter = () => {
                    const commentInput = textarea({attr: {placeholder: 'comment'}})
                    const commentBtn = button({onpointerdown() {
                        const content = commentInput.value.trim()
                        if (content.length == 0) return
                        writeWrit({
                            content,
                            kind: 'comment',
                            tags: 'comment ' + ts,
                            public: true,
                            price: 0,
                            state: '{}'
                        })
                        commentInput.value = ''
                    }}, 'comment')
                    return section.comment_writer(commentInput, commentBtn)
                }
                const commentsEl = article.comments({$},
                    commentWriter(),
                    section.comments(...(comments || []).map(makeComment))
                )
            }
        }

        const blog = section.blog()
        let lastSearchQuery = '', page = 0
        //let cachedWrits = JSON.parse(localStorage.getItem('cachedWrits') || '{}')
        const searchForWrits = async (q = search.value.trim(), p = 0, k = 'post') => {
            page = lastSearchQuery == q ? page + 1 : 0
            //const localResults = Object.values(cachedWrits).filter(w => w && [w.title, w.tags, w.content].map(v => v && v.includes(k)))
            const remoteResults = await http.get('/api/search?q=' + q + `&p=${page}&k=${k}`)
            if (!remoteResults) {
                if (page > 0) {
                    page = page - 1
                    remoteResults = await http.get('/api/search?q=' + q + `&p=${page}&k=${k}`)
                } else {
                    const nf = span.nothing_found(404)
                    ae.before(nf)
                    setTimeout(() => nf.remove(), 3500)
                }
                return
            }
            //console.log(remoteResults, localResults)
            const writs = [/*...localResults,*/ ...remoteResults].filter((w, i, a) => a.findIndex(w2 => w2.ts == w.ts) == i)
            if (writs.length) {
                lastSearchQuery = q
                blog.innerHTML = ''
                let i = -1
                for (const writ of writs) {
                    if (writ.content.trim() == 'access denied' || (writ.content == '' && writ.price > 0)) {
                        writ.content = `<button class="pw" onclick="buyWritAccess(this, ${writ.ts}, "${writ.tags}")">Paid post, Buy Access for ${writ.price} shok space shekels</button>`
                    }
                    // cachedWrits[writ.ts] = writ
                    // localStorage.setItem('cachedWrits', JSON.stringify(cachedWrits))
                    const titleEl = writ.title.length ? `<h2 class="title">${writ.title}</h2>` : '',
                    we = article.writ(html`<header>${titleEl}
<div class="meta">
    <span data-ts="${writ.ts}">${niceTime(writ.ts)}</span>
    ${divider}
    <span>${writ.owner_moniker}</span>
    ${divider}
    <button class="menu-btn">‚öôÔ∏è</button>
</div>
</header>
<section class="content"><pre>${ writ.content || 'no content found'}</pre></section>
<footer>
    <p class="tags">
        ${writ.tags.split(' ').map(t => `<span class="tag" onclick="searchTag(this)">${t}</span>`).join('')}
    </p>
    <p class="interactions">
        <span class="likes">${writ.likes.length}</span>
        <button class="like-button" onclick="likeWrit('${writ.ts}', this)">üëç</button>
        <button class="fetch-comments" onclick="fetchComments('${writ.ts}', this)">üó®Ô∏è</button>
    </p>
</footer>`)
                    blog.append(we)
                }
            } else {
                const nf = span.nothing_found({$:si.parentNode}, 404)
                setTimeout(() => nf.remove(), 3500)
            }
        }

        document.body.addEventListener('pointerdown', e => {
            if (e.target.classList.contains('menu-btn')) {
                const menu = e.target.parentNode.parentNode.parentNode.querySelector('.menu')
                if (menu) {
                    menu.remove()
                } else {
                    const writ = e.target.parentNode.parentNode.parentNode
                    const ts = writ.querySelector('[data-ts]').getAttribute('data-ts')
                    const menu = article.menu({$pre: writ}, 
                        button({async onpointerdown() {
                            const res = await http.del('/api/search/' + ts)
                            if (res.ok) {
                                writ.remove()
                            }
                        }}, 'delete'),
                        button({async onpointerdown() {
                            const w = await http.get('/api/search?ts='+ts)
                            editing = ts
                            wTitle.value = w.title
                            wContent.value = w.content
                            wTags.value = w.tags
                            wPrice.value = w.price
                            wState.value = w.state
                            view('writer')
                        }}, 'edit')
                    )
                }
            }
        })

        window.searchTag = async function searchTag(tag) {
            await searchForWrits(si.value = 'tags:'+tag.textContent)
            view('blog')
        }

        window.buyWritAccess = async function buyWritAccess(btn, ts, tags) {
            await searchForWrits('post tags:"' + tags + '"')
            const res = await http.get('/api/access/' + ts)
            if (res.ok) {
                btn.remove()
                showMessage('me', 'access granted to writ: ' + ts)
            } else {
                showMessage('error', 'could not buy access to writ: ' + ts)
            }
            view('blog')
        }

        searchForWrits('post')
        si.onkeydown = e => {
            if (e.key === 'Enter') {
                searchForWrits(si.value)
                view('blog')
            }
        }

        view('blog', blog)

        let editing, opt = ' (optional)', req = ' (required)'
        const wTitle = input({attr: {type: 'text', required: false, placeholder: 'title'+opt}})
        const wContent = textarea({attr: {required: true, placeholder: 'content'+req}})
        const wTags = input({attr: {type: 'text', placeholder: 'tags'+req, required: true}})
        const wPrice = input({attr: {type: 'number', min: 0, max: 1000000, title: 'price'+opt}})
        const wPublic = input({attr: {type: 'checkbox', checked: true, title: 'public'}})
        const wState = input({attr: {type: 'text', required: false, placeholder: 'json statefield'+opt, title: 'statefield'}})

        wTags.onkeydown = e => wTags.value = [...wTags.value]
            .filter(c => ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '-' || c == '‚Äî' || c == '_' || c == '.' || c == ' ' || c == ',' || c == '!' || c == '?' || c == '&' || c == '(' || c == ')' || c == ':' || c == ';' || c == '"' || c == '\'' || c == '*' || c == '@' || c == '+' || c == '/' || c == ']' || c == '[' || c == '=')).join('')
            .replace('  ', ' ').replace('--', '‚Äî').split(' ')
            .filter((t, i, a) => a.indexOf(t) == i).filter((t, i, a) => a.findIndex(t2 => t2.toLowerCase() == t.toLowerCase()) == i)
            .join(' ')

        const wwRoot = section.writ_writer('writ-Writer', 
            wTitle, wContent, wTags, wState, wPrice, wPublic, 
            button({onpointerdown() {
                const w = {
                    title: wTitle.value.trim(),
                    content: wContent.value.trim(),
                    kind: 'post',
                    tags: 'post ' + wTags.value.trim().replace('  ', ' ').replace('post', ''),
                    public: wPublic.checked,
                    price: Number(wPrice.value) || undefined,
                    state: wState.value.trim() || '{}'
                }
                if (editing != null) w.ts = Number(editing)
                writeWrit(w)
            }}, 'save'),
            button({onpointerdown() {
                editing = undefined
                wTitle.value = ''
                wContent.value = ''
                wTags.value = ''
                wPrice.value = ''
                wState.value = ''
            }}, 'clear')
        )
        view('writer', wwRoot)

        const writeWrit = async writ => {
            showMessage('me', 'writing post...')
            const res = await http[writ.ts == null ? 'put' : 'patch']('/api/search', writ)        
            if (res.ok) {
                editing = null
                wTitle.value = ''
                wContent.value = ''
                wTags.value = ''
                wPrice.value = ''
                wState.value = ''
                searchForWrits('post')
                view('blog')
                showMessage('me', 'post written!')
            }
            view('blog')
        }

        view('about', async () => {
            const about = section.about()
            about.innerHTML = await http.get('/about.html')
            return about
        })

        view(localStorage.getItem('av') || 'blog')

        const whos = JSON.parse(localStorage.getItem('whos') || '{}')
        const status = header.status()
        const chatMessages = article.messages()
        const chatInput = textarea()
        status.innerHTML = "Connecting..."
        chatInput.placeholder = 'type a message..'
        // on control+enter, send message
        chatInput.onkeydown = async e => {
            if (!e.ctrlKey && e.key === 'Enter') {
                e.preventDefault()
                const body = chatInput.value.trim()
                if (body.length == 0) return
                if (body == '/clear') {
                    localStorage.setItem('c', '[]')
                    return chatMessages.innerHTML = ''
                }
                await fetch(`/api/chat`, {method: "POST", body})
                showMessage('me', body)
                chatInput.value = ''
            }
        }
        const chatRoot = section.chat({$: 'body'}, status, chatMessages, chatInput)

        const getWho = async who => {
            if (who == 'me') return 'me'
            if (who == null) return null
            if (who == 'error') return who
            if (whos[who] == null) {
                whos[who] = (await http.get('/api/moniker-lookup/' + who)).moniker
                localStorage.setItem('whos', JSON.stringify(whos))
            }
            return whos[who]
        }

        const makeMessage = async (who, data) => {
            if (who != 'me') {
                if (who != null && whos[who] == null) {
                    if (who == 'error') {
                        return showMessage('error', 'probably not authenticated right')
                    } else if (who != 'me') {
                        whos[who] = (await http.get('/api/moniker-lookup/' + who)).moniker
                        localStorage.setItem('whos', JSON.stringify(whos))
                    }
                }
            }
            if (who == undefined) who = 'me'
            const msg = article.message({$: chatMessages}, span.who[whos[who]](whos[who] || 'me'), p(data))
            if (who == 'me') msg.classList.add('me')
            const msgs = [...(JSON.parse(localStorage.getItem('c') || '[]')), [who, data]]
            for (let i = 0; i < msgs.length; i++) {
                for (let j = 0; j < msgs.length; j++) {
                    if (i == j) continue
                    if (msgs[i][0] == msgs[j][0] && msgs[i][1] == msgs[j][1]) {
                        msgs.splice(j, 1)
                    }
                }
            }
            localStorage.setItem('c', JSON.stringify([...msgs]))
        }
        const showMessage = async (who, data) => {
            if (typeof who == 'string' && who.includes('error')) {
                status.classList.add('error')
                if (data && data.includes && data.includes('found')) {
                    setTimeout(() => {
                        status.classList.remove('error')
                        status.innerHTML = "Connected!"
                    }, 3500)
                }
                status.innerHTML = who + ': ' + data || ''
                return
            }
            if (data == null && who.includes(":")) {
                let wd = who.split(":")
                who = wd.shift()
                data = wd.join(':')
                if (who == 'me') return makeMessage(who, data)
            } else {
                whos[who] = who
            }
            makeMessage(who, data)
        }
        JSON.parse(localStorage.getItem('c') || '[]').forEach(wd => makeMessage(...wd))
        try {
            let tries = (localStorage.getItem('auth') || '').length ? 10 : 0
            const startSSE = () => {
                if (tries-- <= 0) {
                    status.innerHTML = "Lost the connection!"
                    status.classList.add('error')
                    status.onpointerdown = e => {
                        status.onpointerdown = null
                        status.classList.remove('error')
                        status.innerHTML = "Reconnecting..."
                        tries = 3
                        startSSE()
                    }
                    showMessage('error', 'sse failed to connect')
                    tries = 0
                    return
                }
                let sse = new EventSource(`/api/chat`), sid
                sse.addEventListener("account", e => sid = e.data)
                sse.addEventListener("message", e => showMessage(e.data))
                sse.addEventListener("open", () => {
                    status.classList.remove('error')
                    status.innerHTML = "Connected!"
                })
                sse.addEventListener("error", async e => {
                    sse.close()
                    status.innerHTML = "Disconnected!"
                    status.classList.add('error')
                    await showMessage(`error: ${e}`)
                    setTimeout(() => {
                        status.classList.remove('error')
                        status.innerHTML = "Reconnecting..."
                        startSSE()
                    }, 1000)
                })
                return sse
            }
            if (tries == 0) {
                status.classList.remove('error')
                status.innerHTML = "Not authenticated, chat disabled"
            } else {
                startSSE()
            }
        } catch(e) {
            showMessage('error: ', `${e} ${e.message} ${e.stack}`)
        }
        query('.kur').onclick = e => window.open('https://kurshok.space', '_blank')
        query('.shok').onclick = e => window.open('https://github.com/SaulDoesCode/shok', '_blank')
    </script>
</body>
</html>