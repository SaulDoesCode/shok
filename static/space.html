<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/marx.css">
    <link rel="stylesheet" href="/ks.css">
    <title>kurshok.space</title>
</head>
<body>
    <header>
        <h1><span>kur</span><span>shok</span></h1>
        <nav class="vs">
            <header class="avd"></header>

        </nav>
        <input type="search">

        <section class="auth" title="register/login">
            <span class="inputs">
                <input type="text" placeholder="moniker">
                <input type="password" placeholder="password">
            </span>
            <button class="auth-btn" title="authenticate">üîì</button>
        </section>
    </header>
    <main>

    </main>

    <script type="module">
        import d from "/domlib.js"
        import http from "/http.js"

        const {query, queryEach, render, domfn} = d
        const {section, div, button, span, p, header, article, input, textarea, html} = domfn

        const svsapi = '/api/svs/', svs = new Proxy({
            async get(m) { return await http.get(svsapi+m) },
            async set(m, v) { return await http.post(svsapi+m, v) },
            async delete(m) { return await http.del(svsapi+m) }
        }, {
            async get(m, k) { return k in m ? m[k] : (await m.get(k)).value },
            async set(m, k, v) { return await m.set(k, v) },
            async deleteProperty(m, k) { return await m.delete(k) }
        })

        const displayObjectText = obj => {
            let text = ''
            for (const key in obj) text += `${key}: ${obj[key]}\n`
            return text
        }

        const authenticate = async () => {
            const ae = query('.auth')
            try {
                const data = await http.post('/auth', {
                    moniker: query('[type="text"]', ae).value.trim(),
                    pwd: query('[type="password"]', ae).value.trim()
                })
                // display the result then remove the auth form
                if (data.err == null) {
                    ae.innerHTML = `<p>Authenticated</p><p>Info: ${displayObjectText(data)}</p>`
                    setTimeout(() => { ae.remove() }, 4200)
                    localStorage.setItem('auth', 'true')
                }
            } catch(e) {
                const errMsg = html`<p class="auth-err">Authentication Failed, error: ${e}</p>`[0][0]
                ae.append(errMsg)
                setTimeout(() => errMsg.remove(), 4200)
            }
        }

        const ae = query('.auth')
        if (localStorage.getItem('auth')) {
            ae.innerHTML = ''
            button.unauth({
                $: ae,
                attr: {
                    title: 'Unauthenticate/Logout'
                },
                async onpointerdown(e) {
                    localStorage.removeItem('auth')
                    const data = await http.get('/unauth')
                    query('.auth').innerHTML = `
                        <p>Unauthenticated</p>
                        <p>Server Response Info: ${displayObjectText(data)}</p>
                    `
                    setTimeout(() => location.reload(), 4200)
                }
            }, 'üîí ')
            ae.classList.add('unauth')
        } else {
            query('button', ae).onpointerdown = e => authenticate()
            query('[type="password"]', ae).onkeydown = e => {
                if (e.key === 'Enter') authenticate()
            }
        }

        const main = query('main')
        const vs = query('.vs')
        const avd = query('.avd')
        const si = query('input[type=search]')

        const views = Object.create(null)
        const view = (title, v) => {
            if (v != null) {
                views[title] = v
                return vs.appendChild(span({
                    attr: {title},
                    onpointerdown(e) {(e.preventDefault(), view(title))}
                }))
            }
            main.innerHTML = ''
            localStorage.setItem('av', title)
            render(views[avd.textContent = title], main)
        }

        const divider = "<span class=\"divider\"> | </span>"
        const niceTime = ts => `${(ts = new Date(ts * 1000)).getFullYear() - 2000}/${ts.getMonth()}/${ts.getDate()} ${ts.getHours()}:${ts.getMinutes()}${ts.getSeconds() == 0 ? '' : ':' + ts.getSeconds()}`

        const writLikes = async ts => {
            try {
                const res = await (await fetch('/api/writ-likes/' + ts)).json()
                if (!res.err) {
                    return res[0] && res[0].length || 0
                }
            } catch(e) {}
            return 0
        }

        window.likeWrit = async (ts, el) => {
            const res = await (await fetch(`/api/like/${ts}`)).json()
            try {
                el.parentNode.querySelector('.likes').textContent = await writLikes(ts)
            } catch(e) {}
            return res.ok
        }

        const blog = section.blog()
        let lastSearchQuery = '', page = 0
        //let cachedWrits = JSON.parse(localStorage.getItem('cachedWrits') || '{}')
        const searchForWrits = async (q = search.value.trim(), p = 0, k = 'post') => {
            page = lastSearchQuery == q ? page + 1 : 0
            //const localResults = Object.values(cachedWrits).filter(w => w && [w.title, w.tags, w.content].map(v => v && v.includes(k)))
            const remoteResults = await http.get('/api/search?q=' + q + `&p=${page}&k=${k}`)
            //console.log(remoteResults, localResults)
            const writs = [/*...localResults,*/ ...remoteResults].filter((w, i, a) => a.findIndex(w2 => w2.ts == w.ts) == i)
            if (writs.length) {
                lastSearchQuery = q
                blog.innerHTML = ''
                let i = -1
                for (const writ of writs) {
                    // cachedWrits[writ.ts] = writ
                    // localStorage.setItem('cachedWrits', JSON.stringify(cachedWrits))
                    blog.append(article.writ(html`
<header>
    <h2>${writ.title}</h2>
    <div>
        <span data-ts="${writ.ts}">${niceTime(writ.ts)}</span>
        ${divider}
        <span>${writ.owner_moniker}</span>
        ${divider}
        <button class="menu-btn">‚öôÔ∏è</button>
    </div>
</header>
<section>
    <pre>
${writ.content || (writ.price > 0 ? '<button class="pw" onclick="buyWritAccess(this, \`${writ.ts}\`)">Paid post, Buy Access</button>' : 'no content found')}
    </pre>
</section>
<footer>
    <p class="tags">
        ${writ.tags.split(' ').map(t => `<span class="tag" onclick="searchTag(this)">${t}</span>`).join('')}
    </p>
    <p class="interactions">
        <span class="likes">${writ.likes.length}</span>
        <button class="like-button" onclick="likeWrit('${writ.ts}', this)">üëç</button>
    </p>
</footer>`))
                }
            } else {
                const nf = span.nothing_found({$:si.parentNode}, 404)
                setTimeout(() => nf.remove(), 3500)
            }
        }

        document.body.addEventListener('pointerdown', e => {
            if (e.target.classList.contains('menu-btn')) {
                const menu = e.target.parentNode.parentNode.parentNode.querySelector('.menu')
                if (menu) {
                    menu.remove()
                } else {
                    const writ = e.target.parentNode.parentNode.parentNode
                    const ts = writ.querySelector('[data-ts]').getAttribute('data-ts')
                    const menu = article.menu({$pre: writ}, 
                        button({async onpointerdown() {
                            const res = await http.del('/api/search/' + ts)
                            if (res.ok) {
                                writ.remove()
                            }
                        }}, 'delete'),
                        button({async onpointerdown() {
                            const w = await http.get('/api/search?ts='+ts)
                            editing = ts
                            wTitle.value = w.title
                            wContent.value = w.content
                            wTags.value = w.tags
                            wPrice.value = w.price
                            wState.value = w.state
                            view('writer')
                        }}, 'edit')
                    )
                }
            }
        })

        window.searchTag = async function searchTag(tag) {
            await searchForWrits(si.value = 'tags:'+tag.textContent)
            view('blog')
        }

        window.buyWritAccess = async function buyWritAccess(btn, ts) {
            await searchForWrits('post')
            const res = await http.get('/api/access/' + ts)
            if (res.ok) {
                btn.remove()
                showMessage('me', 'access granted to writ: ' + ts)
            } else {
                showMessage('error', 'could not buy access to writ: ' + ts)
            }
            view('blog')
        }

        searchForWrits('post')
        si.onkeydown = e => {
            if (e.key === 'Enter') {
                searchForWrits(si.value)
                view('blog')
            }
        }

        view('blog', blog)

        let editing
        const wTitle = input({attr: {type: 'text', required: false, placeholder: 'title (optional)'}})
        const wContent = textarea({attr: {required: true, placeholder: 'content (required)'}})
        const wTags = input({attr: {type: 'text', pattern: '[a-zA-Z0-9 ]+', placeholder: 'tags (required)', required: true}})
        const wPrice = input({attr: {type: 'number', min: 0, max: 1000000, title: 'price (optional)'}})
        const wPublic = input({attr: {type: 'checkbox', checked: true, title: 'public'}})
        const wState = input({attr: {type: 'text', required: false, placeholder: 'json statefield (optional)'}})
        
        const wwRoot = section.writ_writer('writ-Writer', 
            wTitle, wContent, wTags, wState, wPrice, wPublic, 
            button({onpointerdown() {
                const w = {
                    title: wTitle.value.trim(),
                    content: wContent.value.trim(),
                    kind: 'post',
                    tags: 'post ' + wTags.value.trim(),
                    public: wPublic.checked,
                    price: Number(wPrice.value) || undefined,
                    state: wState.value.trim() || '{}'
                }
                if (editing != null) {
                    w.ts = Number(editing)
                } 
                writeWrit(w)
            }}, 'save')
        )
        view('writer', wwRoot)

        const writeWrit = async writ => {
            showMessage('me', 'writing post...')
            const res = await http[writ.ts == null ? 'put' : 'patch']('/api/search', writ)        
            if (res.ok) {
                editing = null
                wTitle.value = ''
                wContent.value = ''
                wTags.value = ''
                wPrice.value = ''
                wState.value = ''
                searchForWrits('post')
                view('blog')
                showMessage('me', 'post written!')
            }
            view('blog')
        }

        view('about', section.about(p("Homespun server and frontend"), html`
<article>
Welcome to kurshok.space, a new blog and platform for philosophical content and paid posts. Kurshok.space is more than just a website, it is a community of thinkers, writers, and readers who share a passion for exploring the big questions of life.

Kurshok.space is powered by Rust, a fast and reliable programming language that ensures high performance and security. Rust also enables us to create social features akin to Twitter, such as search, timelines, likes, and reposting. You can follow your favorite authors, interact with their posts, and discover new perspectives on various topics.

Kurshok.space is also a publishing platform (WIP) that will allow you to monetize your content with points on the website that can be purchased/fundged from the admin, who is contactable at saul@kurshok.space. You can create your own blog, choose your subscription model, and earn money from your loyal readers.

Kurshok.space is a place where you can express yourself freely, learn from others, and grow as a person. Whether you are interested in ethics, metaphysics, logic, or anything in between, you will find something that sparks your curiosity and challenges your mind.
</article>
<article>
<header>
    Privacy Policy: 
</header>
    We do not collect any personal information from you. We do not use cookies or any other tracking technology. We do not share your data with third parties. We do not sell your data to advertisers. We do not store your data on our servers. We do not store your data on your device. We do not store your data anywhere. We do not store data you did not enter here to be stored, like moniker and posts. 
    We use a cookie for auth, there are no stats on the backend, and the frontend is practically static.
    Chat messages are not stored on the server, they are persisted only on localStorage.
    Private posts are accessible only to the admin and the author. All posts can be deleted by the author or the admin, as need be.
    The admin is contactable at saul@kurshok.space
    The code is open source, so you can see for yourself how things are handled, no surprises.
    The server is privately hosted, and the domain is privately owned, tls encryption is used.
</article>
<article>
<header>
Terms of Use:
</header>
Don't spam, don't be a doos/asshole. Be respectful of the server's capacity. Don't use the server for anything illegal.
</article>
</article>
<article>
<header>
Liability:
</header>
Seeing as this is less than a spaza shop at this point, and run by me sometimes. Please save whatever needs saved, contact me if there are issues.
I am not responsible for what you get up to on this server, I do not take accountablility for what you say or publish here.
By using the site, you agree to these conditions, respectfully.
</article>
        `))

        view(localStorage.getItem('av') || 'blog')

        const whos = JSON.parse(localStorage.getItem('whos') || '{}')
        const status = header.status()
        const chatMessages = article.messages()
        const chatInput = textarea()
        status.innerHTML = "Connecting..."
        chatInput.placeholder = 'type a message..'
        // on control+enter, send message
        chatInput.onkeydown = async e => {
            if (!e.ctrlKey && e.key === 'Enter') {
                e.preventDefault()
                const body = chatInput.value.trim()
                if (body.length == 0) return
                if (body == '/clear') {
                    localStorage.setItem('c', '[]')
                    return chatMessages.innerHTML = ''
                }
                await fetch(`/api/chat`, {method: "POST", body})
                showMessage('me', body)
                chatInput.value = ''
            }
        }
        const chatRoot = section.chat({$: 'body'}, status, chatMessages, chatInput)

        const makeMessage = async (who, data) => {
            if (who != 'me') {
                if (who != null && whos[who] == null) {
                    if (who == 'error') {
                        return showMessage('error', 'probably not authenticated right')
                    }
                    whos[who] = (await http.get('/api/moniker-lookup/' + who)).moniker
                    localStorage.setItem('whos', JSON.stringify(whos))
                }
            }
            const msg = article.message({$: chatMessages}, span.who[whos[who]](whos[who] || 'me'), p(data))
            if (who == 'me') msg.classList.add('me')
            const msgs = [...(JSON.parse(localStorage.getItem('c') || '[]')), [who, data]]
            for (let i = 0; i < msgs.length; i++) {
                for (let j = 0; j < msgs.length; j++) {
                    if (i == j) continue
                    if (msgs[i][0] == msgs[j][0] && msgs[i][1] == msgs[j][1]) {
                        msgs.splice(j, 1)
                    }
                }
            }
            localStorage.setItem('c', JSON.stringify([...msgs]))
        }
        const showMessage = async (who, data) => {
            // santize the who, no html space characters
            who = who.replace(/</g, '&lt;').replace(/>/g, '&gt;')
            data = data.replace(/</g, '&lt;').replace(/>/g, '&gt;')
            if (typeof who == 'string' && who.includes('error')) {
                status.classList.add('error')
                status.innerHTML = who + ': ' + data
                return
            }
            if (data == null && who.includes(":")) {
                let wd = who.split(":")
                who = wd.shift()
                data = wd.join(':')
                if (who == 'me') return makeMessage(who, data)
            } else {
                whos[who] = who
            }
            makeMessage(who, data)
        }
        JSON.parse(localStorage.getItem('c') || '[]').forEach(wd => makeMessage(...wd))
        try {
            let tries = (localStorage.getItem('auth') || '').includes('true') ? 10 : 0
            const startSSE = () => {
                if (tries-- <= 0) {
                    status.innerHTML = "Lost the connection!"
                    status.classList.add('error')
                    // add a once listener on the status element that will retry to connect
                    status.onpointerdown = e => {
                        status.onpointerdown = null
                        status.classList.remove('error')
                        status.innerHTML = "Reconnecting..."
                        tries = 3
                        startSSE()
                    }
                    showMessage('error', 'sse failed to connect')
                    tries = 0
                    return
                }
                let sse = new EventSource(`/api/chat`), sid
                sse.addEventListener("account", e => sid = e.data)
                sse.addEventListener("message", e => showMessage(e.data))
                sse.addEventListener("open", () => status.innerHTML = "Connected!")
                sse.addEventListener("error", async e => {
                    sse.close()
                    status.innerHTML = "Disconnected!"
                    status.classList.add('error')
                    await showMessage(`error: ${e}`)
                    setTimeout(() => {
                        status.classList.remove('error')
                        status.innerHTML = "Reconnecting..."
                        startSSE()
                    }, 1000)
                })
                return sse
            }
            console.log(tries)
            if (tries == 0) {
                status.innerHTML = "Not authenticated, chat disabled"
            } else {
                startSSE()
            }
        } catch(e) {
            showMessage('error: ', `${e} ${e.message} ${e.stack}`)
        }
    </script>
</body>
</html>